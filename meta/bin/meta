#!/usr/bin/env groovy

/*
 * Copyright (c) 2010, The Regents of the University of California, through Lawrence Berkeley
 * National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * (1) Redistributions of source code must retain the above copyright notice, this list of conditions and the
 * following disclaimer.
 *
 * (2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions
 * and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory, U.S. Dept.
 * of Energy, nor the names of its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the
 * features, functionality or performance of the source code ("Enhancements") to anyone; however,
 * if you choose to make your Enhancements available either publicly, or directly to Lawrence Berkeley
 * National Laboratory, without imposing a separate written license agreement for such Enhancements,
 * then you hereby grant the following license: a  non-exclusive, royalty-free perpetual license to install,
 * use, modify, prepare derivative works, incorporate into other computer software, distribute, and
 * sublicense such enhancements or derivative works thereof, in binary and source code form.
 */


import gov.jgi.meta.command.*
import org.apache.log4j.Logger
import org.apache.log4j.PropertyConfigurator;


Logger log = Logger.getLogger("meta")

/**
 * the set of commands that are configured
 */


commandList = [
        new blastCommand(),
        new dereplicateCommand(),
        new contigkmerCommand()
//        new fastqToFastaCommand()
];

HashMap<String, command> commandMap = new HashMap();
commandList.each { it -> commandMap[it.name()] = it }


/* ==================================== */
/* = commandline processing functions = */
/* ==================================== */


/**
 *  processes the argments from commandline and returns map.
 *  flags are boolean and params take the following argument as value
 *
 * @param flag list of flags in the form ['-b', '-d',]
 * @param params is list of flags that take a value
 * @param args is the commandline argment as list
 * @return map file of the form ['-d': true, '-x': 'value']
 */
Map processArgs(Set flags, Set params, List<String> args) {
  boolean error = false;
  Map options = [:]

  //
  // first process any java options of the form -Dxxx=yyy
  //
  newargs = [];
  options["java"] = "";
  args.each {a ->
    if (a ==~ /^-D[\S]+(=.*)+$/ ) {
      options["java"] = options["java"] + " " + a;
    } else {
      newargs.add(a);
    }
  }
  args = newargs;

  //
  // process the flags first
  //
  flags.each {f ->
    if (args.contains(f)) {
      options[f] = true
      args.remove(f)
    }
  }

  //
  // now for the parameters
  //
  params.each {p ->
    if (args.contains(p)) {

      // the value of the parameter is the next in sequence

      def v = args[args.findIndexOf { it == p} + 1]

      // make sure value is not a parameter

      if (v && v[0] != '-') {
        options[p] = v
        args.remove(v)
        args.remove(p)
      } else {
        // if no value is found set error but continue
        error = true
      }
    }
  }

  options['error'] = error

  //
  // now set the remaining unused args in options.args[0] ...
  //
  options['args'] = args

  return options
}

/**
 * prints the usage for the command
 */
void printUsage() {
  println("usage: meta <command> <options>")
  println("commands:")
  commandList.each { c ->
      println("\t" + c.usage())
  }
}

/* ======================= */
/* = Script starts here  = */
/* ======================= */

/*
        setup the parameters and process commandline
*/

List largs = (List) args

Set flags = ['-d', '--help', '-?'] as Set;
Set params = [] as Set;

commandList.each { c ->
    List t = c.options()
    if ( t ) {
       t[0].each {l -> flags.add(l)}
       t[1].each {l -> params.add(l)}
    }
}

log.debug("flags = " + flags);
log.debug("params = " + params);
log.debug("largs = " + largs);

def options = processArgs(flags, params, largs)

/*

 now load the prefs from the ~/.meta-prefs file

*/

props = new Properties()
try {
  java.io.FileInputStream fis = new java.io.FileInputStream(new java.io.File(System.env['HOME'] + "/.meta-prefs"))
  props.load(fis)
  props.each {it ->
      if (options['-d']) {
          println("added property: " + it.key + "/" + it.value);
      }
      System.setProperty( (String) it.key, (String) it.value)

   }
  log.debug("loaded config file from ~/.meta-prefs")
  log.debug("example: meta.defaultKeyspace = " + System.getProperty("meta.defaultKeyspace"))
  if (options['-d']) {
    println("loaded config file from ~/.meta-prefs")
    println("example: meta.defaultKeyspace = " + System.getProperty("meta.defaultKeyspace"))
  }

  /*
  configure the log4j logging system while we are at it
   */
  PropertyConfigurator.configure(System.env['HOME'] + "/.meta-prefs")
} catch (IOException e) {
  log.debug("Config file ~/.meta-prefs not found or loaded")
  if (options['-d']) {
    println("Config file ~/.meta-prefs not found or loaded")
  }
}


/*

        now figure out what to do

*/

if (options['--libversion']) {
  println("meta version = ...");
  System.exit(0)
}

if (options.error) {
  printUsage()
  System.exit(1)
}

if (options['-d']) {
  println "options = " + options
}

if (options['--help'] || options['-?']) {
  printUsage()
  System.exit(0)
}

/*
        determine major command
*/
command = options.args[0]

log.debug("command = " + command)
if (options['-d']) println("command = " + command)

def longAsByteArray(Long s) {
  bos = new java.io.ByteArrayOutputStream();
  dos = new java.io.DataOutputStream(bos);
  dos.writeLong(s);
  dos.flush();
  return bos.toByteArray();
}

/*
       execute command
 */
commandMap[command]?.execute(options.args, options);

