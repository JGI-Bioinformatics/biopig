#!/usr/bin/env groovy

/*
 * Copyright (c) 2010, Joint Genome Institute (JGI) United States Department of Energy
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by the JGI.
 * 4. Neither the name of the JGI nor the
 *    names of its contributors may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JGI ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL JGI BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


import gov.jgi.meta.command.*
import org.apache.log4j.Logger
import org.apache.log4j.PropertyConfigurator;


/**
 * properties file that contains the various configuration parameters for this script
 */

Logger log = Logger.getLogger("meta")


/**
 * the set of commands that are configured
 */

commandList = [ new loadCommand(), new scanCommand(), new loadHashCommand(), new blastCommand() ];


/* ==================================== */
/* = commandline processing functions = */
/* ==================================== */


/**
 *  processes the argments from commandline and returns map.
 *  flags are boolean and params take the following argument as value
 *
 * @param flag list of flags in the form ['-b', '-d',]
 * @param params is list of flags that take a value
 * @param args is the commandline argment as list
 * @return map file of the form ['-d': true, '-x': 'value']
 */
Map processArgs(Set flags, Set params, List args) {
  boolean error = 0
  Map options = [:]

  //
  // process the flags first
  //
  flags.each {f ->
    if (args.contains(f)) {
      options[f] = true
      args.remove(f)
    }
  }

  //
  // now for the parameters
  //
  params.each {p ->
    if (args.contains(p)) {

      // the value of the parameter is the next in sequence

      def v = args[args.findIndexOf { it == p} + 1]

      // make sure value is not a parameter

      if (v && v[0] != '-') {
        options[p] = v
        args.remove(v)
        args.remove(p)
      } else {
        // if no value is found set error but continue
        error = true
      }
    }
  }

  options['error'] = error

  //
  // now set the remaining unused args in options.args[0] ...
  //
  options['args'] = args

  return options
}

/**
 * prints the usage for the command
 */
void printUsage() {
  println("usage: meta <command> <options>")
  println("commands:")
  commandList.each { c ->
      println("\t" + c.usage())
  }
}

/* ======================= */
/* = Script starts here  = */
/* ======================= */

/*
        setup the parameters and process commandline
*/

List largs = (List) args

Set flags = ['-d', '--help', '-?'];
Set params = [];

commandList.each { c ->
    List t = c.options()
    if ( t ) {
       t[0].each {l -> flags.add(l)}
       t[1].each {l -> params.add(l)}
    }
}

println("flags = " + flags);
println("params = " + params);

def options = processArgs(flags, params, largs)

// now load the prefs from the ~/.meta-prefs file
props = new Properties()
try {
  java.io.FileInputStream fis = new java.io.FileInputStream(new java.io.File(System.env['HOME'] + "/.meta-prefs"))
  props.load(fis)
  props.each {it ->
      if (options['-d']) {
          println("added property: " + it.key + "/" + it.value);
      }
      System.setProperty(it.key, it.value)

   }
  if (options['-d']) {
    println("loaded config file from ~/.meta-prefs")
    println("example: meta.defaultKeyspace = " + System.getProperty("meta.defaultKeyspace"))
  }
  //configure the log4j logging system
  PropertyConfigurator.configure(System.env['HOME'] + "/.meta-prefs")
} catch (IOException e) {
  if (options['-d']) {
    println("Config file ~/.meta-prefs not found or loaded")
  }
}


/*
        now figure out what to do
*/

if (options['--libversion']) {
  println("meta version = ...");
  System.exit(0)
}

if (options.error) {
  printUsage()
  System.exit(1)
}

if (options['-d']) {
  println "options = " + options
}

if (options['--help'] || options['-?']) {
  printUsage()
  System.exit(0)
}

/*
        determine major command
*/
command = options.args[0]
if (options['-d']) println("command = " + command)


def longAsByteArray(Long s) {
  bos = new java.io.ByteArrayOutputStream();
  dos = new java.io.DataOutputStream(bos);
  dos.writeLong(s);
  dos.flush();
  return bos.toByteArray();
}


switch (command) {

    //------------------------------------------------------------------------------------------
    //                                     SCAN Command
    //------------------------------------------------------------------------------------------
  case "scan":

      commandList[1].execute(options.args, options);

  break;

//------------------------------------------------------------------------------------------
//                                     LOAD Command
//------------------------------------------------------------------------------------------

  case("load"):

      commandList[0].execute(options.args, options);

  break;

  case("hash"):

    commandList[2].execute(options.args, options);

    break;

//------------------------------------------------------------------------------------------
//                                     blast Command
//------------------------------------------------------------------------------------------

  case ('blast'):

    commandList[3].execute(options.args, options);

  break;



//------------------------------------------------------------------------------------------
//                                     delete Command
//------------------------------------------------------------------------------------------

  case ('delete'):

  /*
   want to delete set of keys
   */


  break;

//------------------------------------------------------------------------------------------
//                                     QUERY Command
//------------------------------------------------------------------------------------------



//------------------------------------------------------------------------------------------
//                                     delete Command
//------------------------------------------------------------------------------------------




//------------------------------------------------------------------------------------------
//                                     delete Command
//------------------------------------------------------------------------------------------



}

